name: .NET Core Desktop

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]
  workflow_dispatch:
    inputs:
      bump:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch

  #----------------------------------------------------------------------------------------------------------------------------------------
env:
  # Replace with your solution name, i.e. MyWpfApp.sln.
  SOLUTION_NAME: "./ErikForwerk.TestAbstractions.slnx"
  PROJECT_BASE: "./ErikForwerk.TestAbstractions/ErikForwerk.TestAbstractions.csproj"
  PROJECT_STA: "./ErikForwerk.TestsAbstractions.STA/ErikForwerk.TestAbstractions.STA.csproj"

jobs:

  #----------------------------------------------------------------------------------------------------------------------------------------
  build:

    strategy:
      matrix:
        CONFIGURATION: [Debug, Release]

    # For a list of available runner types, refer to
    # https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on
    runs-on: windows-latest

    permissions:
      contents: read  # Required to checkout code

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Install the .NET Core workload
    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 9.0.x

    # Add  MSBuild to the PATH: https://github.com/microsoft/setup-msbuild
    - name: Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v2

    # Restore the application
    - name: Restore the application
      run: dotnet restore $env:SOLUTION_NAME

    # Build the solution
    - name: Build solution
      run: dotnet build $env:SOLUTION_NAME --configuration $env:Configuration --no-restore
      env:
        Configuration: ${{ matrix.CONFIGURATION }}

    # Execute all unit tests in the solution without rebuilding
    - name: Execute unit tests
      run: dotnet test $env:SOLUTION_NAME --configuration $env:Configuration --no-build --collect:"XPlat Code Coverage;Format=json,cobertura"
      env:
        Configuration: ${{ matrix.CONFIGURATION }}

    # taken from a Codecov example
    - name: Upload coverage reports to Codecov
      uses: codecov/codecov-action@v5
      with:
        token: ${{ secrets.CODECOV_TOKEN }}
        files: ./TestResults/**/*.cobertura.xml
        flags: unittests
    #   name: codecov-umbrella

  #----------------------------------------------------------------------------------------------------------------------------------------
  pack-and-publish:
    needs: build
    # Only run on main branch when tests are successful
    if: github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    permissions:
      contents: write  # Required to create and push tags
      packages: write  # Required for publishing packages

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Install the .NET Core workload
    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 9.0.x

    # Determine the latest version tag and calculate new version
    - name: Determine new version
      id: version
      shell: bash # Explicitly use Bash
      run: |
        # The Bash-logic for determine the new version
        # ------------------------------------

        # 1. fetch tags
        git fetch --tags

        # 2. Find the last SemVer-tag
        # Sort the tags and select the last (highest) one.
        latestTag=$(git tag -l "v*.*.*" | sort -V | tail -n 1)

        if [ -z "$latestTag" ]; then
          # No tag found, start at 0.0.0
          latestTag="v0.0.0"
        fi

        # 3. Extract version parts
        # Remove the 'v' and split version
        version=${latestTag#v}
        IFS='.' read -r major minor patch <<< "$version"

        # 4. determine Bump-type (Fallback to 'patch')
        bump_type="${{ github.event.inputs.bump }}"
        if [ -z "$bump_type" ]; then
          bump_type="patch"
        fi

        # 5. Increase version
        case "$bump_type" in
          major)
            major=$((major + 1))
            minor=0
            patch=0
            ;;
          minor)
            minor=$((minor + 1))
            patch=0
            ;;
          patch)
            patch=$((patch + 1))
            ;;
        esac

        newVersion="$major.$minor.$patch"
        newTag="v$newVersion"

        # 6. Outputs to log
        echo "Previous version: $latestTag"
        echo "New version: $newTag"

        # 7. Output as environment variable for following steps
        echo "version=$newVersion" >> $GITHUB_OUTPUT
        echo "tag=$newTag" >> $GITHUB_OUTPUT

    # Create and push new version tag
    - name: Create version tag
      shell: bash
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag ${{ steps.version.outputs.tag }}
        git push origin ${{ steps.version.outputs.tag }}

    # Build the solution with new version
    - name: Build solution
      shell: bash
      # use environment variable in Bash like: $PROJECT_PATH (without "env:")
      # since this is a new step, we have to rebuild everything
      # ansd since we build windows-target under linux, we need to add "/p:EnableWindowsTargeting=true"
      run: |
        dotnet build $PROJECT_BASE --configuration Release /p:Version=${{ steps.version.outputs.version }} /p:EnableWindowsTargeting=true
        dotnet build $PROJECT_STA --configuration Release /p:Version=${{ steps.version.outputs.version }} /p:EnableWindowsTargeting=true

    # Pack the NuGet package
    - name: Pack NuGet package
      id: pack
      shell: bash
      run: |
        PACKAGE_VERSION="${{ steps.version.outputs.version }}"
        # The dotnet pack command
        dotnet pack $PROJECT_BASE --configuration Release --no-build /p:PackageVersion=$PACKAGE_VERSION --output ./nupkg /p:EnableWindowsTargeting=true
        dotnet pack $PROJECT_STA --configuration Release --no-build /p:PackageVersion=$PACKAGE_VERSION --output ./nupkg /p:EnableWindowsTargeting=true

        # Determine and save the exact package name for the push step (Fail-Safe)
        PACKAGE_NAME_BASE=$(basename $PROJECT_BASE .csproj | sed 's/\.csproj$//')
        PACKAGE_NAME_STA=$(basename $PROJECT_STA .csproj | sed 's/\.csproj$//')
        
        NUPKG_PATH_BASE="./nupkg/${PACKAGE_NAME_BASE}.${PACKAGE_VERSION}.nupkg"
        NUPKG_PATH_STA="./nupkg/${PACKAGE_NAME_STA}.${PACKAGE_VERSION}.nupkg"

        # Setzt den exakten Pfad als Output
        echo "nupkg_path_base=$NUPKG_PATH_BASE" >> $GITHUB_OUTPUT
        echo "nupkg_path_sta=$NUPKG_PATH_STA" >> $GITHUB_OUTPUT

    # Publish to NuGet.org
    - name: Publish to NuGet
      shell: bash
      run: |
        dotnet nuget push ${{ steps.pack.outputs.nupkg_path_base }} --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json --skip-duplicate
        dotnet nuget push ${{ steps.pack.outputs.nupkg_path_sta }} --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json --skip-duplicate
      # TODO: try the following syntax:
      # dotnet nuget push ./artifacts/*.nupkg --api-key ${{ secrets.NUGET_API_KEY }} --source https://api.nuget.org/v3/index.json --skip-duplicate
        
